// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"text/template"
)

var (
	file string
	url  string = `http://www.unicode.org/Public/UNIDATA/Blocks.txt`
	out  string = `blocks_generated.go`
)

func main() {
	flag.StringVar(&url, "url", url, "url to read Blocks.txt from")
	flag.StringVar(&file, "file", file, "path to local copy of Blocks.txt file to read")
	flag.StringVar(&out, "out", out, "file to write generated output to")
	flag.Parse()
	var (
		r   io.ReadCloser
		err error
	)
	switch {
	case len(out) == 0:
		log.Fatal("-out flag should be set to non-empty value")
	case len(file) > 0:
		r, err = os.Open(file)
		if err != nil {
			log.Fatal(err)
		}
	case len(url) > 0:
		resp, err := http.Get(url)
		switch {
		case err != nil:
			log.Fatal(err)
		case resp.StatusCode != 200:
			log.Fatalf("Fail on %q read: %s", url, resp.Status)
		}
		r = resp.Body
	default:
		log.Fatal("Either -url or -file flags should be set")
	}
	defer r.Close()
	blocks := make([]block, 0)
	scanner := bufio.NewScanner(r)
	for scanner.Scan() {
		if len(scanner.Bytes()) == 0 || bytes.HasPrefix(scanner.Bytes(), []byte("#")) {
			continue
		}
		s := bytes.SplitN(scanner.Bytes(), []byte("; "), 2)
		if len(s) != 2 {
			log.Fatalf("Invalid line: %q", scanner.Text())
		}
		b := block{Name: string(s[1])}
		s = bytes.SplitN(s[0], []byte(".."), 2)
		if len(s) != 2 {
			log.Fatalf("Invalid line: %q", scanner.Text())
		}
		if b.Begin, err = strconv.ParseInt(string(s[0]), 16, 64); err != nil {
			log.Fatalf("Invalid offset begin: %q", scanner.Text())
		}
		if b.End, err = strconv.ParseInt(string(s[1]), 16, 64); err != nil {
			log.Fatalf("Invalid offset end: %q", scanner.Text())
		}
		blocks = append(blocks, b)
	}
	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}
	f, err := os.Create(out)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	if err := t.Execute(f, blocks); err != nil {
		log.Fatal(err)
	}
}

type block struct {
	Begin, End int64
	Name       string
}

func init() {
	t = template.Must(template.New("out").Parse(tpl))
}

var t *template.Template

var tpl string = `// this file is automatically generated by go generate, do not edit

package lang

func getBlock(char rune) string {
	switch {
{{range .}}	case {{printf "%#x" .Begin}} <= char && char <= {{printf "%#x" .End}}:
		return {{printf "%q" .Name}}
{{end}}	}
	return ""
}
`
